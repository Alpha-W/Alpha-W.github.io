==========================
Julia1.0学习笔记
==========================
:Author: Hau Wong
:Date:   2018-08-11
:Category: 计算机语言

开始
==========================
与Python类似，Julia支持REPL模式，可以在命令行中编写Julia程序．

若要退出，可键入Ctrl + D,或用exit()语句．

先试试一些数学表达式吧:

julia> 1+2*(3/4+1/3)

3.1666666666666665

 

julia> ans*12

38.0

 

可以看出julia支持四则运算的直接输出,ans为上一步的计算结果．如果不想输出结果，可以在表达式末尾加分号（;）．这与Matlab是一致的．

 

我们可以将表达式写在文件file里，然后使用命令include(“file”)即可计算结果

另一种方式是在命令行模式下（没有进入julia）键入julia script arg1 arg2 ...

这里script文件里已经写好了julia程序，arg1 arg2 ...为输入的参数．同样可以计算结果

julia命令内置了一些选项，可以在命令行模式下用julia -h 或julia --help　查看：

变量
==========================
所有的变量名都是引用，故没有严格的类型审查机制：

julia> x=1

1

julia> x=”Hello World!”

”Hello World!”

 

不仅支持Unicode字符串，还支持Unicode字符作变量名：

julia> proverb = “朝霞不出门，晚霞行千里”

“朝霞不出门，晚霞行千里”

 

julia> 数学=”mathematics”

”mathematics”

 

甚至支持用LaTeX表示符号,比如要打出＂δ＂，可以输入＼delta再加tab键即可．

julia预定义了一些变量与函数，如pi,sqrt()等等,并且可以自己重新定义变量：

julia> pi=3

3

julia> pi

3

 

但如果之前就使用过某预定义变量，则再重新定义此变量会报错：

julia> pi

π=3.1415926535897...

 

julia> pi=3

ERROR: cannot assign variable MathConstants.pi from module Main

 

变量名可以以英文字母，下划线，以及Unicode码中大于00A0的字符开头．

变量名使用运算符时，运算符不会被视为变量名的一部分;用关键字作变量名会报错．

julia> !+r=1

ERROR: syntax: "+(r)" is not a valid function argument name

 

julia> else=1

ERROR: syntax: unexpected "else"

 

julia变量命名规范：

１．变量名应使用小写字母

２．在不影响阅读的情况下单词之间不使用分隔符，特殊情况下使用下划线分隔单词　

３．类型(Type)名与模块(Module)名以大写字母开头，单词之间的分隔以大写字母来体现

４．函数(functions)名与宏(micros)名使用小写字母，不使用下划线

５．函数名的选择应见名知意

 

---------------------------------------------------2018.08.11---------------------------------------

 

整数与浮点数
==========================
+-------------+--------+----------+---------+--------+-------+
|             | 类型   |长度(bit) | 最小值  | 最大值 | 特殊值|
+-------------+--------+----------+---------+--------+-------+
| 整数        | Int8   | 8        | -2^7    | 2^7-1  | 无    |
+-------------+--------+----------+---------+--------+-------+
| Int16       | 16     | -2^15    | 2^15-1  | 无     |       |
+-------------+--------+----------+---------+--------+-------+
| Int32       | 32     | -2^31    | 2^31-1  | 无     |       |
+-------------+--------+----------+---------+--------+-------+
| Int64       | 64     | -2^63    | 2^63-1  | 无     |       |
+-------------+--------+----------+---------+--------+-------+
| Int128      | 128    | -2^127   | 2^127-1 | 无     |       |
+-------------+--------+----------+---------+--------+-------+
| Int   (1*)  | 32/64  |          |         |        |       |
+-------------+--------+----------+---------+--------+-------+
| BigInt      | -      | -        | -       | 无     |       |
+-------------+--------+----------+---------+--------+-------+
| 无符号整数  | UInt8  | 8        | 0       | 2^8-1  | 无    |
+-------------+--------+----------+---------+--------+-------+
| UInt16      | 16     | 0        | 2^16-1  | 无     |       |
+-------------+--------+----------+---------+--------+-------+
| UInt32      | 32     | 0        | 2^32-1  | 无     |       |
+-------------+--------+----------+---------+--------+-------+
| UInt64      | 64     | 0        | 2^64-1  | 无     |       |
+-------------+--------+----------+---------+--------+-------+
| UInt128     | 128    | 0        | 2^128-1 | 无     |       |
+-------------+--------+----------+---------+--------+-------+
| UInt  (1*)  | 32/64  |          |         |        |       |
+-------------+--------+----------+---------+--------+-------+
| 布尔值      | Bool   | 8        | false(0)| true(1)| 无    |
+-------------+--------+----------+---------+--------+-------+
| 浮点数      | Float16| 16       | -Inf16  | Inf16  | NaN16 |
+-------------+--------+----------+---------+--------+-------+
| Float32     | 32     | -Inf32   | Inf32   | NaN32  |       |
+-------------+--------+----------+---------+--------+-------+
| Float64     | 64     | -Inf64   | Inf64   | NaN64  |       |
+-------------+--------+----------+---------+--------+-------+
| Float  (1*) | 32/64  | -Inf     | Inf     | NaN    |       |
+-------------+--------+----------+---------+--------+-------+
| BigFloat    | -      | -Inf     | Inf     | NaN    |       |
+-------------+--------+----------+---------+--------+-------+

(1*):

Int,UInt,Float,Inf,NaN与操作系统位数有关

32位系统上对应xxx32,64位系统上对应xxx64

 

先介绍几个函数：

typeof(a) 返回a的类型；

typemax(t) 返回类型t的最大值

typemin(t) 返回类型t的最小值

 

整数

整数字面量一般默认类型为Int,但当字面量数值超出Int范围时，则转换为更高位数的整数型:

julia> typeof(1)

Int64

 

julia> typeof(9223372036854775808)

Int128

 

二进制，八进制，十六进制字面量分别以0b,0o,0x开头，julia均视之为无符号整数．

所占位数由字面量值决定.其输出格式均为十六进制：

julia> typeof(0b01)

UInt8

 

julia> typeof(0o777)

UInt16

 

julia> typeof(0xffffff)

UInt32

 

julia> typeof(0b111111111111)

UInt16

 

julia> typeof(0xf)

UInt8

 

julia> 0o77777

0x7fff

 

 

对一个二进制，八进制，十六进制数取补码可用”-”符号：

julia> -0x0f

0xf1

 

当整数作运算后超出所属类型的范围时会发生溢出，具体行为与Ｃ语言中整数溢出行为类似，

整数除法（÷）在以下两种情况下会抛出异常（DivideError）:

(1)　某一整数除以0时;

(2) typemin(Int)除以-1时．(将Int换为大于Int位数的整数类型也会异常)

julia> typemax(Int64)+1==typemin(Int64)

true

 

julia> typemax(Int8)+1==typemin(Int8)

false												(2*)

 

julia> typemin(Int64)÷(-1)

ERROR: DivideError: integer division error

 

julia> typemin(Int8)÷(-1)

128													(2*)

 

julia> 1÷0

ERROR: DivideError: integer division error

 

(2*) 这是因为typemin(Int8)是Int类型

 

我们可以使用BigInt类型来避免溢出的发生：

julia> typemax(Int64)+1>0

false

 

julia> BigInt(typemax(Int64))+1>0

true

 

浮点数

以下为浮点数表示的几个例子：

julia> 10_000.

10000.0

julia> -.23

-0.23

 

julia> 1e10

1.0e10

 

julia> 2.5e-4

0.00025

 

julia> typeof(0.5e0)

Float64

 

julia> 0x.4p-1

0.125

 

julia> typeof(0x1p0)

Float64

 

与整数不同的是，浮点数字面量默认类型均为Float64．

如果需要Float32类型的浮点数，可以用f替换上例中的e来表示：

julia> typeof(0.5f0)

Float32

 

还可以用Float32()函数转换成Float32类型：

julia> typeof(Float32(0.5))

Float32

 

而Float16类型的浮点数只能通过Float16()转换得到，不仅如此，这一类型浮点数也只能以Float16()的形式打印．

julia> Float16(8)+Float16(1.2)

Float16(9.2)

 

浮点数有两种零，一个是正零，一个是负零，两者值相等，但存储的数位不同：

利用bitstring()函数，我们可以了解数是以怎样的形式存储的．

julia> 0.0==-0.0

true

 

julia> bitstring(0.0)

"0000000000000000000000000000000000000000000000000000000000000000"

 

julia> bitstring(-0.0)

"1000000000000000000000000000000000000000000000000000000000000000"

Inf,-Inf,NaN,0的关系：a/0=sgn(a)Inf		a/Inf=sgn(a)0.0		a/-Inf=-sgn(a)0.0

a+Inf=Inf		a-Inf=-Inf		0/0=NaN	Inf+Inf=NaN	Inf-Inf=NaN

Inf*Inf=Inf		Inf/Inf=NaN		0*Inf=NaN

(a为有限数)

 

与Int类型类似，Float类型也有对应的BigFloat类型，主要用于高精度数值的计算：

julia> 1.0/3

0.3333333333333333

 

julia> BigFloat(1.0)/3

3.333333333333333333333333333333333333333333333333333333333333333333333333333348e-01

 

 

parse()函数可以将字符串转化成指定类型的整数，浮点数，布尔值

julia> parse(Int64,"64")

64

 

julia> parse(Bool,"true")

true

 

julia> parse(Float64,"0.0")

0.0

 

我们可以用setrounding()函数来指定BigFloat是向上舍入还是向下舍入，还可以用setprecision()函数来指定精度．一旦设定这两个函数，以后所有BigFloat的行为都会按照设定的返回结果．如果只想若干条语句执行此设定的话，可以用do代码块实现：

julia> setrounding(BigFloat, RoundUp) do

​    BigFloat(1) + parse(BigFloat,"0.1")

​    end

1.100000000000000000000000000000000000000000000000000000000000000000000000000003

 

julia> setrounding(BigFloat, RoundDown) do

​    BigFloat(1) + parse(BigFloat,"0.1")

​    end

1.099999999999999999999999999999999999999999999999999999999999999999999999999986

 

julia> setprecision(10) do 

​    BigFloat(1)+parse(BigFloat,"0.1")

​    end

1.0996

 

julia> setprecision(20) do 

​    BigFloat(1)+parse(BigFloat,"0.1")

​    end

1.1000004

 

注：setprecision(t)表示精度为(1/2)^t.

 

机器零

与Ｃ语言类似，julia也不能完整表示所有实数．如果两个实数的距离比某指定距离更小，julia就认为这两个实数相等，这个指定的距离就称之为＂机器零＂

可用eps()函数来查看机器零数值：

julia> eps(Float16)

Float16(0.000977)

 

julia> eps(Float32)

1.1920929f-7

 

julia> eps(Float64)

2.220446049250313e-16

 

julia> eps()

2.220446049250313e-16

 

当然，与Ｃ语言稍微不同的是，julia的＂机器零＂是会变化的：机器零的数量级始终会与输入的数的数量级保持一定差距．

julia> eps(Float64)

2.220446049250313e-16

 

julia> eps(1e-27)

1.793662034335766e-43

 

julia> eps(1e-44)

1.2446030555722283e-60

 

julia> eps(0.0)

5.0e-324

 

大概你也猜出来了，最小的机器零就是5.0e-324,比这个数还小时,机器零就不会发生变化．

julia> eps(1e-325)

5.0e-324

 

julia提供nextfloat()与prevfloat()函数来得到某一浮点数的下一个浮点数与上一个浮点数，它们的二进制位分别是在原有浮点数上加一或减一得到的．

julia> x=1.0f0

1.0f0

 

julia> prevfloat(x)

0.99999994f0

 

julia> nextfloat(x)

1.0000001f0

 

julia> bitstring(prevfloat(x))

"00111111011111111111111111111111"

 

julia> bitstring(x)

"00111111100000000000000000000000"

 

julia> bitstring(nextfloat(x))

"00111111100000000000000000000001"

 

字面量系数

在C语言中输入多项式是一件很烦恼的事，一连串的＊号让人头昏眼花．．．而在julia中，字面量作为变量的系数时可以省略＊号，不过要注意的是:

１．这种运算的优先级高于乘法（＊）和除法（／，＼，／／）,低于负号．比如-1/2x会被解析成-1/(2x)而不是(-1/2)x

２．在与指数运算符结合时，这种运算表现出类似一元运算符的性质．2^3x与2x^3分别被解析为2^(3x)与2(x^3)

此外，julia还支持多项式与单项式相乘省略乘号，比如(x^2+1)x被解析成(x^2+1)＊x

不过在某些情况下这样的代码会让人困惑．为避免歧义，julia还是作了如下规定：

１．以0x开头的十六进制数不会被当作0和一个以”x”开头的变量相乘

２．以科学计数法表示的数不会被当作一个数和一个以”e”，”E”或”f”开头的变量相乘

 

０与１

最后介绍两个函数：zero()和one()．正如函数名那样，这两个函数分别返回参数类型的＂０＂与＂１＂，如果参数就是类型的话就返回该类型的＂０＂与＂１＂：

julia> zero(1.0)

0.0

 

julia> one(Int8)

1

 

julia> one(Float16)

Float16(1.0)

 

----------------------------------------------2018.9.22-------------------------------------------------

 

数学运算符与基本函数
==========================
算术运算符：

以下运算符支持所有基本数值类型（除!x外）

+--------+-------------------------------+
| 表达式 | 说明                          |
+--------+-------------------------------+
| +x     | 恒等运算符                    |
+--------+-------------------------------+
| -x     | x的加法逆元                   |
+--------+-------------------------------+
| x+y    | x与y之和                      |
+--------+-------------------------------+
| x-y    | x与y之差                      |
+--------+-------------------------------+
| x/y    | x与y之商                      |
+--------+-------------------------------+
| x*y    | x与y之积                      |
+--------+-------------------------------+
| x÷y    | x与y之商并向零取整            |
+--------+-------------------------------+
| x\\y   | y与x之商                      |
+--------+-------------------------------+
| x^y    | x的y次方                      |
+--------+-------------------------------+
| x%y    | x对y取余                      |
+--------+-------------------------------+
| !x     | (仅支持Bool类型)　取x取否运算 |
+--------+-------------------------------+
 

位运算符：

以下运算符支持所有基本整数类型

+--------+----------------+
| 表达式 | 说明           |
+--------+----------------+
| ~x     | x逐位取非      |
+--------+----------------+
| x&y    | x与y逐位取且   |
+--------+----------------+
| x\|y   | x与y逐位取或   |
+--------+----------------+
| x⊻y    | x与y逐位取异或 |
+--------+----------------+
| x>>>y  | x逻辑右移y位   |
+--------+----------------+
| x>>y   | x算术右移y位   |
+--------+----------------+
| x<<y   | x算术左移y位   |
+--------+----------------+

 

更新运算符：

所有二元算术运算符与所有二元位运算符均支持更新操作：将该运算符与等号组合，表示左值与右值作该运算后将值赋给左值．

 

向量化的点运算符

点运算符可以与所有二元运算符（包括用户定义的）结合，表示对向量的每个分量作该运算．多个点运算符的计算顺序与单个分量的运算顺序一致．部分点运算符需要加空格以消除歧义：

julia> x=[1,2,3]

3-element Array{Int64,1}:

 1

 2

 3

 

julia> 1.+x

ERROR: syntax: invalid syntax "1.+"; add space(s) to clarify

 

julia> 1 .+x

3-element Array{Int64,1}:

 2

 3

 4

 

julia> y=1

1

 

julia> 1. +y

2.0

 

数值的比较：

标准比较运算符支持所有基本数值类型

+--------+----------+
| 操作符 | 说明     |
+--------+----------+
| ==     | 相等     |
+--------+----------+
| !=,≠   | 不相等   |
+--------+----------+
| <      | 小于     |
+--------+----------+
| <=,≦   | 小于等于 |
+--------+----------+
| >      | 大于     |
+--------+----------+
| >=,≧   | 大于等于 |
+--------+----------+

 

整数判断是否相等的条件是每个二进制位是否相等，浮点数判断相等依据IEEE754标准：

\1. 有限数按照通常顺序比较大小

\2. +0.0与-0.0相等

\3. Inf和他自己相等，且除了NaN之外比任何数都大,与NaN只有不相等成立

\4. -Inf和他自己相等，且除了NaN之外比任何数都小,与NaN只有不相等成立

\5. NaN与任何数只有不相等成立

 

两个向量的大小按字典序排序，长度为a的向量与长度为b的向量（a<b）比较时,只会取前a个分量比较，在比较的分量中如果存在NaN,那么这两个向量只有不相等成立．

数值相同的整数和浮点数相等

 

Julia还提供一些检验特殊值的函数：这些函数是通过hash值来检验的

+--------------+----------------------------+
| 函数         | 说明                       |
+--------------+----------------------------+
| isequal(x,y) | 判断x与y是否相同（hash值） |
+--------------+----------------------------+
| isfinite(x)  | 判断x是否有限              |
+--------------+----------------------------+
| isinf(x)     | 判断x是否无限(Inf,-Inf)    |
+--------------+----------------------------+
| isnan(x)     | 判断x是否非数(NaN)         |
+--------------+----------------------------+

 

julia> hash(1)==hash(1.0)

true

 

julia> hash(NaN)==hash(NaN32)

true

 

julia> isequal(NaN,NaN)

true

 

julia> isequal([1 NaN],[1 NaN])

true

 

julia> isequal(NaN32,NaN)

true

 

julia> isequal(-0.0,0.0)

false

